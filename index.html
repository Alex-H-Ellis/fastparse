<!DOCTYPE html><html><head><link href="META-INF/resources/webjars/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" /><link href="styles.css" rel="stylesheet" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style>
.scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.05;
  text-decoration: none;
}


.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.5;
  text-decoration: none;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:hover{
  opacity: 1.0;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:active{
  opacity: 0.75;
}

.scalatex-site-Styles-content{
  color: #777;
  line-height: 1.6em;
  margin: 0 auto;
  margin-left: auto;
  margin-right: auto;
  max-width: 800px;
  padding: 0 1em;
  padding-bottom: 50px;
}
.scalatex-site-Styles-content *{
  position: relative;
}
.scalatex-site-Styles-content p{
  text-align: justify;
}
.scalatex-site-Styles-content a:link{
  color: #37a;
  text-decoration: none;
}
.scalatex-site-Styles-content a:visited{
  color: #949;
  text-decoration: none;
}
.scalatex-site-Styles-content a:hover{
  text-decoration: underline;
}
.scalatex-site-Styles-content a:active{
  color: #000;
  text-decoration: underline;
}
.scalatex-site-Styles-content code{
  color: #000;
}

/*Workaround for bug in highlight.js IDEA theme*/
span.hljs-tag, span.hljs-symbol{
    background: none;
}
    </style><script src="scripts.js"></script></head><body><div>

<a href="https://github.com/lihaoyi/fastparse" style="position: absolute;top: 0px;right: 0px;border: 0;"><img src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" /></a>


<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="FastParse0.1.7" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">FastParse 0.1.7<a class=" scalatex-site-Styles-headerLink" href="#FastParse0.1.7" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /><h2 style="font-weight: 300;color: #ccc;padding: 0px;margin-top: 0px;">Fast to write, Fast running Parsers in Scala</h2></div><div class=" scalatex-site-Styles-content">
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val number: P[Int] = P( CharIn('0'to'9').rep(1).!.map(_.toInt) )
val parens: P[Int] = P( &quot;(&quot; ~! addSub ~ &quot;)&quot; )
val factor: P[Int] = P( number | parens )

val divMul: P[Int] = P( factor ~ (CharIn(&quot;*/&quot;).! ~! factor).rep ).map(eval)
val addSub: P[Int] = P( divMul ~ (CharIn(&quot;+-&quot;).! ~! divMul).rep ).map(eval)
val expr: P[Int]   = P( addSub ~ End )</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/MathTests.scala#L18-L26" target="_blank"><i class="fa fa-link "></i></a></pre>
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">check(&quot;1+1&quot;, 2)
check(&quot;1+1*2&quot;, 3)
check(&quot;(1+1*2)+(3*4*5)&quot;, 63)
check(&quot;15/3&quot;, 5)
check(&quot;63/3&quot;, 21)
check(&quot;(1+1*2)+(3*4*5)/20&quot;, 6)
check(&quot;((1+1*2)+(3*4*5))/3&quot;, 21)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/MathTests.scala#L33-L40" target="_blank"><i class="fa fa-link "></i></a></pre>
    <div id="splashdiv"></div>
    <script>demo.DemoMain().math(document.getElementById("splashdiv"))</script>
    <p>
        FastParse is a parser-combinator library for Scala that lets you quickly and easily write recursive descent parsers in Scala. Features include:
</p>
    <ul>
        <li>
            Up to 1/5 the speed of a hand-written parser, 100x faster than <a href="https://github.com/scala/scala-parser-combinators">scala-parser-combinators</a>, comparable (though slightly slower than) <a href="https://github.com/sirthias/parboiled2">Parboiled2</a></li>
        <li>
            1/10th the size of a hand-written parser</li>
        <li>
            Automatic, excellent error-reporting and diagnostics.</li>
        <li>
            Zero allocations during a parse</li>
        <li>
            Compatible with both Scala-JVM and Scala.js
</li></ul>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="GettingStarted" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Getting Started<a class=" scalatex-site-Styles-headerLink" href="#GettingStarted" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <p>
            To begin using FastParse, add
</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %% &quot;fastparse&quot; % &quot;0.1.7&quot;
</code></pre>
        <p>
            To your SBT configuration. To use with Scala.js, you'll need</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %%% &quot;fastparse&quot; % &quot;0.1.7&quot;


</code></pre>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="WritingParsers" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Writing Parsers<a class=" scalatex-site-Styles-headerLink" href="#WritingParsers" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <h1 id="Basic" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Basic" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Basic</h1>
            <p>
                The simplest parser matches a single string:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse._
val parseA = P( &quot;a&quot; )

val Result.Success(value, successIndex) = parseA.parse(&quot;a&quot;)
assert(value == (), successIndex == 1)

val failure = parseA.parse(&quot;b&quot;).asInstanceOf[Result.Failure]
assert(
  failure.parser == (&quot;a&quot;: P0),
  failure.index == 0,
  failure.trace == &quot;&quot;&quot;parseA:0 / &quot;a&quot;:0 ...&quot;b&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L14-L26" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Such a parser returns a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result.Success</code> if the input matches the string, and otherwise returns a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result.Failure</code>.</p>
            <p>
                As you can see, by default the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Success</code> contains a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">(): Unit</code>, unless you use <a href="#Capturing">Capturing</a> or <a href="#Map">Map</a> described below. Also, apart from the structured data of the failure, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Failure</code> also contains a nice human-readable trace of the parse showing the stack of parsers which were in progress when the parse failed.
</p>
            <p>
                You can also wrap the strings in an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">IgnoreCase(&quot;...&quot;)</code> if you want the matching to be case-insensitive.
</p>
            <h2 id="Sequence" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Sequence" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Sequence</h2>

                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val ab = P( &quot;a&quot; ~ &quot;b&quot; )

val Result.Success(_, 2) = ab.parse(&quot;ab&quot;)

val Result.Failure(parser, 1) = ab.parse(&quot;aa&quot;)
assert(parser == (&quot;b&quot;: P0))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L29-L35" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    You can combine two parsers with the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~</code> operator. This creates a new parser that only succeeds if both left and right parsers succeed one after another.
</p>
            <h2 id="Repeat" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Repeat" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Repeat</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val ab = P( &quot;a&quot;.rep ~ &quot;b&quot; )

val Result.Success(_, 8) = ab.parse(&quot;aaaaaaab&quot;)
val Result.Success(_, 4) = ab.parse(&quot;aaaba&quot;)

val abc = P( &quot;a&quot;.rep(sep=&quot;b&quot;) ~ &quot;c&quot;).log(&quot;A&quot;)

val Result.Success(_, 8) = abc.parse(&quot;abababac&quot;)

val Result.Failure(parser, 3) = abc.parse(&quot;abaabac&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L37-L47" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> method creates a new parser that attempts to parse the given parser zero or more times. You can optionally provide an argument to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> which acts as a separator between the usages of the original parser, or use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep(1)</code> if you want to parse something one or more times.
</p>
            <h2 id="Optional" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Optional" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Optional</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val option = P( &quot;c&quot;.? ~ &quot;a&quot;.rep(sep=&quot;b&quot;).! ~ End)

val Result.Success(&quot;aba&quot;, 3) = option.parse(&quot;aba&quot;)
val Result.Success(&quot;aba&quot;, 3) = option.parse(&quot;aba&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L50-L54" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    Similar to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> is <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.?</code>, which creates a new parser that attempts to parse the given parser zero or 1 times.
</p>
            <h2 id="Either" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Either" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Either</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val either = P( &quot;a&quot;.rep ~ (&quot;b&quot; | &quot;c&quot; | &quot;d&quot;) ~ End)

val Result.Success(_, 6) = either.parse(&quot;aaaaab&quot;)
val Result.Failure(parser, 5) = either.parse(&quot;aaaaae&quot;)
assert(parser == (&quot;b&quot; | &quot;c&quot; | &quot;d&quot;))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L57-L62" target="_blank"><i class="fa fa-link "></i></a></pre>
                <p>
                    The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">|</code> operator tries the parser on the left, and if that fails, tries the one on the right, failing only if both parsers fail.
</p>
            <h2 id="End,Start" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#End,Start" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>End, Start</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val noEnd = P( &quot;a&quot;.rep ~ &quot;b&quot;)
val withEnd = P( &quot;a&quot;.rep ~ &quot;b&quot; ~ End)

val Result.Success(_, 4) = noEnd.parse(&quot;aaaba&quot;)
val Result.Failure(End, 4) = withEnd.parse(&quot;aaaba&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L66-L72" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">End</code> parser only succeeds if at the end of the input string. By default, a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser</code> does not need to consume the whole input, and can succeed early consuming a portion of it (exactly how much input was consumed is stored in the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Success#index</code> attribute). By using <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">End</code>, we can make the parse fail if it doesn't consume everything
</p>
                <p>
                    There is also a similar <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Start</code> parser, which only succeeds at the start of the input</p>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val ab = P( ((&quot;a&quot; | Start) ~ &quot;b&quot;).rep ~ End).!

val Result.Success(&quot;abab&quot;, 4) = ab.parse(&quot;abab&quot;)
val Result.Success(&quot;babab&quot;, 5) = ab.parse(&quot;babab&quot;)

val Result.Failure(parser, 2) = ab.parse(&quot;abb&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L74-L81" target="_blank"><i class="fa fa-link "></i></a></pre>

            <h2 id="Pass,Fail" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Pass,Fail" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Pass, Fail</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val Result.Success((), 0) = Pass.parse(&quot;asdad&quot;)
val Result.Failure(Fail, 0) = Fail.parse(&quot;asdad&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L84-L86" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    These two parsers always succeed, or always fail, respectively. Neither consumes any input.
</p>
            <h2 id="Index" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Index" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Index</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val finder = P( &quot;hay&quot;.rep ~ Index ~ &quot;needle&quot; ~ &quot;hay&quot;.rep )

val Result.Success(9, _) = finder.parse(&quot;hayhayhayneedlehay&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L89-L92" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    Always succeeds, and provides the current index of the parse into the input string. e.g. useful for providing source locations for AST nodes. Consumes no input.
</p>
            <h2 id="Capturing" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Capturing" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Capturing</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val capture1 = P( &quot;a&quot;.rep.! ~ &quot;b&quot; ~ End)

val Result.Success(&quot;aaa&quot;, 4) = capture1.parse(&quot;aaab&quot;)

val capture2 = P( &quot;a&quot;.rep.! ~ &quot;b&quot;.! ~ End)

val Result.Success((&quot;aaa&quot;, &quot;b&quot;), 4) = capture2.parse(&quot;aaab&quot;)

val capture3 = P( &quot;a&quot;.rep.! ~ &quot;b&quot;.! ~ &quot;c&quot;.! ~ End)

val Result.Success((&quot;aaa&quot;, &quot;b&quot;, &quot;c&quot;), 5) = capture3.parse(&quot;aaabc&quot;)

val captureRep = P( &quot;a&quot;.!.rep ~ &quot;b&quot; ~ End)

val Result.Success(Seq(&quot;a&quot;, &quot;a&quot;, &quot;a&quot;), 4) = captureRep.parse(&quot;aaab&quot;)

val captureOpt = P( &quot;a&quot;.rep ~ &quot;b&quot;.!.? ~ End)

val Result.Success(Some(&quot;b&quot;), 4) = captureOpt.parse(&quot;aaab&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L95-L114" target="_blank"><i class="fa fa-link "></i></a></pre>
                <p>
                    So far, all the parsers go over the input text but do not return any useful value: the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Success#value</code> attribute was always <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">()</code>. In order to make them do so, you use the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.!</code> operation to capture the section of the input string the parser parsed.</p>
                <p>
                    Note the types of each parser:</p>
                <ul>
                    <li>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">capture1</code> is a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[String]</code></li>
                    <li>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">capture2</code> is a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[(String, String)]</code></li>
                    <li>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">capture3</code> is a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[(String, String, String)]</code></li>
                    <li>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">captureRep</code> is a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Seq[String]]</code></li>
                    <li>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">captureOpt</code> is a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Opt[String]]</code></li></ul>
                <p>
                    In general, if you have a parser of type <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">TupleN</code>, capturing one more section turns it into a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">TupleN+1</code>. Furthermore, if you capture within a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.?</code> optional parser, it becomes a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Seq[T]]</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Option[T]]</code> respectively</p>
            <h2 id="AnyChar" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#AnyChar" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>AnyChar</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val ab = P( &quot;'&quot; ~ AnyChar.! ~ &quot;'&quot; )

val Result.Success(&quot;-&quot;, 3) = ab.parse(&quot;'-'&quot;)

val Result.Failure(parser, 2) = ab.parse(&quot;'-='&quot;)
assert(parser == (&quot;'&quot;: P0))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L116-L122" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    This parser parses any single character successfully.
</p>
            <h2 id="PositiveLookahead" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#PositiveLookahead" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Positive Lookahead</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val keyword = P( (&quot;hello&quot; ~ &amp;(&quot; &quot;)).!.rep )

val Result.Success(Seq(&quot;hello&quot;), _) = keyword.parse(&quot;hello &quot;)
val Result.Success(Seq(), __) = keyword.parse(&quot;helloX&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L126-L130" target="_blank"><i class="fa fa-link "></i></a></pre>
                <p>
                    The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&amp;(...)</code> operator wraps a parser, only succeeds if it succeeds, but consumes no input. Useful for doing checks like &quot;these characters must be followed by a whitespace, but don't consume the whitespace&quot;
</p>
            <h2 id="NegativeLookahead" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#NegativeLookahead" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Negative Lookahead</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val keyword = P( &quot;hello&quot; ~ !&quot; &quot; ~ AnyChar ~ &quot;world&quot; ).!

val Result.Success(&quot;hello-world&quot;, _) = keyword.parse(&quot;hello-world&quot;)
val Result.Success(&quot;hello_world&quot;, _) = keyword.parse(&quot;hello_world&quot;)

val Result.Failure(parser, 6) = keyword.parse(&quot;hello world&quot;)
assert(parser == !(&quot; &quot;))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L132-L139" target="_blank"><i class="fa fa-link "></i></a></pre>
                <p>
                    The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">!...</code> operator wraps a parser and only succeeds of it fails, also consuming no input. Useful to combine with other parsers like <a href="#AnyChar">AnyChar</a> to restrict the things that they can parse.</p>
            <h2 id="Map" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Map" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Map</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val binary = P( (&quot;0&quot; | &quot;1&quot; ).rep.! )
val binaryNum = P( binary.map(Integer.parseInt(_, 2)) )

val Result.Success(&quot;1100&quot;, _) = binary.parse(&quot;1100&quot;)
val Result.Success(12, _) = binaryNum.parse(&quot;1100&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L141-L146" target="_blank"><i class="fa fa-link "></i></a></pre>
                <p>
                    Up till now, we've only dealt with</p>
                <ul>
                    <li>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Unit]</code>: the default case</li>
                    <li>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[String]</code>: after capturing something with <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.!</code></li>
                    <li>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[TupleN[String]]</code>: capturing multiple things in series</li>
                    <li>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Seq[String]]</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Option[String]]</code>: capturing things in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.?</code>
</li></ul>
                <p>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.map</code> lets you convert an arbitrary <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[T]</code> into a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[V]</code> by providing a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">T =&gt; V</code> function. This is useful for converting the strings and tuples/seqs/options of strings into more useful data-structures.</p>
            <h2 id="FlatMap" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#FlatMap" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>FlatMap</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val leftTag = P( &quot;&lt;&quot; ~ (!&quot;&gt;&quot; ~ AnyChar).rep(1).! ~ &quot;&gt;&quot; )
def rightTag(s: String) = P( &quot;&lt;/&quot; ~ s.! ~ &quot;&gt;&quot; )
val xml = P( leftTag.flatMap(rightTag) )

val Result.Success(&quot;a&quot;, _) = xml.parse(&quot;&lt;a&gt;&lt;/a&gt;&quot;)
val Result.Success(&quot;abcde&quot;, _) = xml.parse(&quot;&lt;abcde&gt;&lt;/abcde&gt;&quot;)

val failure = xml.parse(&quot;&lt;abcde&gt;&lt;/edcba&gt;&quot;).asInstanceOf[Result.Failure]
assert(
  failure.trace == &quot;&quot;&quot;xml:0 / rightTag:7 / &quot;abcde&quot;:9 ...&quot;edcba&gt;&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L148-L159" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.flatMap</code> allows you to dynamically choose a parser to continue with, given the result of the current parser. The example above uses it to parse balanced XML tags. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.flatMap</code> can be used to parse indentation-based grammars, and is used to do so in <a href="http://lihaoyi.github.io/Scalatex/">Scalatex</a>.
</p>
                <p>
                    Note that the function given to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.flatMap</code> is evaluated every time this parser is tried. You should be conscious of the cost of re-creating the resultant parser every time, since FastParse parsers are somewhat expensive to initialize despite being fast per-run. If possible, store the parsers somewhere before-hand or memo-ize/cache them to avoid initializing them wastefully.</p>
            <h2 id="Filter" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Filter" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Filter</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val digits = P(CharIn('0' to '9').rep(1).!).map(_.toInt)
val even = digits.filter(_ % 2 == 0)
val Result.Success(12, _) = even.parse(&quot;12&quot;)
val failure = even.parse(&quot;123&quot;).asInstanceOf[Result.Failure]
assert(even.toString == &quot;digits.filter(&lt;function1&gt;)&quot;)
assert(failure.trace == &quot;digits.filter(&lt;function1&gt;):0 ...\&quot;123\&quot;&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L161-L167" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.filter</code> allows you to supply a predicate <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">T =&gt; Boolean</code> which is applied to the successful Result of the current parser. If the result of the predicate is true the filtered parser succeeds - otherwise it fails. The example above uses <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.filter</code> to parse only even numbers - odd number will fail. If the current parser fails then that failure is simply passed along.
</p>
        <h1 id="Intrinsics" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Intrinsics" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Intrinsics</h1>
            <p>
                In theory, all possible parsers can be put together using the above tools. In practice, a few more tools are provided for convenience or performance:
</p>
            <h2 id="CharPred" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CharPred" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>CharPred</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val cp = P( CharPred(CharPredicates.isUpper).rep.! ~ &quot;.&quot; ~ End )

val Result.Success(&quot;ABC&quot;, _) = cp.parse(&quot;ABC.&quot;)
val Result.Failure(_, 2) = cp.parse(&quot;ABc.&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L171-L175" target="_blank"><i class="fa fa-link "></i></a></pre>
                <p>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharPred</code> takes a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Char =&gt; Boolean</code> predicate and creates a parser that parses any single character that satisfies that predicate. e.g. you can use any of the helpful methods on <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">scala.Char</code> to check if a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Char</code> <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">isUpper</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">isDigit</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">isControl</code>, etc. etc.
</p>
                <p>
                    Note that this builds a high-performance bit-packed lookup table, the size of the range of valid characters, up to 65k. That means that creating a parser like this has a one-time cost in terms of memory (up to 8k bytes) and time. This should not matter as FastParse parsers are long-lived and re-usable, though you may want to consciously avoid creating too many of these repeatedly.
</p>
            <h2 id="CharIn" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CharIn" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>CharIn</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val ci = P( CharIn(&quot;abc&quot;, &quot;xyz&quot;).rep.! ~ End )

val Result.Success(&quot;aaabbccxyz&quot;, _) = ci.parse(&quot;aaabbccxyz&quot;)
val Result.Failure(_, 7) = ci.parse(&quot;aaabbccdxyz.&quot;)

val digits = P( CharIn('0' to '9').rep.! )

val Result.Success(&quot;12345&quot;, _) = digits.parse(&quot;12345abcde&quot;)
val Result.Success(&quot;123&quot;, _) = digits.parse(&quot;123abcde45&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L177-L186" target="_blank"><i class="fa fa-link "></i></a></pre>
                <p>
                    Similar to <a href="#CharPred">CharPred</a>, except you pass in sequences of valid characters rather than a predicate.
</p>
                <p>
                    As a result, it's much faster to execute than if you had used <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | ...</code> to combine a bunch of single-character parsers together. The same warning as <a href="#CharPred">CharPred</a> about the one time cost-of-construction applies.
</p>
            <h2 id="CharsWhile" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CharsWhile" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>CharsWhile</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val cw = P( CharsWhile(_ != ' ').! )

val Result.Success(&quot;12345&quot;, _) = cw.parse(&quot;12345&quot;)
val Result.Success(&quot;123&quot;, _) = cw.parse(&quot;123 45&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L188-L192" target="_blank"><i class="fa fa-link "></i></a></pre>
                <p>
                    A repeated version of <a href="#CharPred">CharPred</a>: this parser continually chomps away at characters as long as they continue passes the given predicate.
</p>
                <p>
                    This is a very fast parser, ideal for quickly consuming large numbers of characters. The same warning as <a href="#CharPred">CharPred</a> about the one time cost-of-construction applies.
</p>
            <h2 id="StringIn" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#StringIn" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>StringIn</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val si = P( StringIn(&quot;cow&quot;, &quot;cattle&quot;).!.rep )

val Result.Success(Seq(&quot;cow&quot;, &quot;cattle&quot;), _) = si.parse(&quot;cowcattle&quot;)
val Result.Success(Seq(&quot;cow&quot;), _) = si.parse(&quot;cowmoo&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L194-L198" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    Quickly parses one of any number of strings that you give it. Behind the scenes, it converts the list of strings into a Trie so it can attempt to parse all of them in a single pass.
</p>
                <p>
                    As a result, this is much faster to execute than if you had combined the individual strings with <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;cow&quot; | &quot;cattle&quot; | ...</code>.</p>
        <h1 id="Cuts" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Cuts" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Cuts</h1>
            <p>
                A &quot;cut&quot; is a marker in a recursive-descent parser that states &quot;you cannot backtrack past this point&quot;. Although in theory it allows you to save on memory usage by discarding earlier portions of the input, in FastParse this operator is mostly used to improve on the quality of error reporting.
</p>
            <h2 id="NoCuts" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#NoCuts" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>No Cuts</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val alpha = P( CharIn('a' to 'z') )
val nocut = P( &quot;val &quot; ~ alpha.rep(1).! | &quot;def &quot; ~ alpha.rep(1).!)

val Result.Success(&quot;abcd&quot;, _) = nocut.parse(&quot;val abcd&quot;)

val failure = nocut.parse(&quot;val 1234&quot;).asInstanceOf[Result.Failure]
assert(
  failure.index == 0,
  failure.trace ==
  &quot;&quot;&quot;nocut:0 / (&quot;val &quot; ~ alpha.rep(1) | &quot;def &quot; ~ alpha.rep(1)):0 ...&quot;val 1234&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L202-L213" target="_blank"><i class="fa fa-link "></i></a></pre>
                <p>
                    Above we have a naive scala definition parser: it either parses a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">val</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">def</code>, a space, and its (lower-case only) name. On a success this works as expected, and extracts the name. However, on a failure, something odd happens: the deepest parser on-failure is shown to be the entire <a href="#Either">Either</a>, rather than just the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">alpha</code> that came after <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;val &quot;</code>. Why is that?
</p>
                <p>
                    By default, the parse has an opportunity to backtrack whenever it enters a
</p>
                <ul>
                    <li>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p1 | p2</code>: If <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p1</code> fails, it tries <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p2</code>
</li>
                    <li>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p.rep</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p.?</code>: If parsing with <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p</code> fails, it backtracks out of the failed parse and tries to parse whatever comes after the repeat/optional.</li></ul>
                <p>
                    e.g. in the case of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p1 | p2</code>, if it tries to parse <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p1</code> and fails, it then tries to parse <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p2</code>. If <i>that</i> fails, all that FastParse knows is that one of them should have succeeded. Specifically, FastParse does <i>not</i> know that after successfully parsing <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;val &quot;</code>, that only the left branch of the <a href="#Either">Either</a> is viable! Thus it has no choice but to offer both alternatives in the error message.
</p>
            <h2 id="Cuts" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Cuts" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Cuts</h2>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val alpha = P( CharIn('a' to 'z') )
val nocut = P( &quot;val &quot; ~! alpha.rep(1).! | &quot;def &quot; ~! alpha.rep(1).!)

val Result.Success(&quot;abcd&quot;, _) = nocut.parse(&quot;val abcd&quot;)

val failure = nocut.parse(&quot;val 1234&quot;).asInstanceOf[Result.Failure]
assert(
  failure.index == 4,
  failure.trace ==
  &quot;&quot;&quot;nocut:0 / alpha:4 / CharIn(&quot;abcdefghijklmnopqrstuvwxyz&quot;):4 ...&quot;1234&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L215-L226" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    Cuts are added using the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~!</code> operator, which is similar to the <a href="#Sequence">Sequence</a> operator <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~</code>. Once the parse has crossed a cut, it can no longer backtrack past the point at which the cut occured. Hence, in this case you can see that it no longer backtracks to index 0, out of the enclosing <a href="#Either">Either</a> parser and offering that in the error trace. Instead, it shows a much more precise error: at index <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">4</code>, expecting one of the small set of alphanumeric characters.</p>
                <p>
                    In general, if you know that a parser is &quot;committed&quot; to one branch after parsing to a certain point, adding a cut will greatly improve the error message by ensuring that the parser <i>itself</i> knows that. Good places to add cuts include places like after keywords in a programming language parser, where a keyword can be followed by only one thing and anything else is an error.</p>
            <h2 id="RepCuts" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#RepCuts" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Rep Cuts</h2>

                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val alpha = P( CharIn('a' to 'z') )
val stmt = P( &quot;val &quot; ~ alpha.rep(1).! ~ &quot;;&quot; ~ &quot; &quot;.rep )
val stmts = P( stmt.rep(1) ~ End )

val Result.Success(Seq(&quot;abcd&quot;), _) = stmts.parse(&quot;val abcd;&quot;)
val Result.Success(Seq(&quot;abcd&quot;, &quot;efg&quot;), _) = stmts.parse(&quot;val abcd; val efg;&quot;)

val failure = stmts.parse(&quot;val abcd; val &quot;).asInstanceOf[Result.Failure]
assert(
  failure.index == 10,
  failure.trace == &quot;&quot;&quot;stmts:0 / End:10 ...&quot;val &quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L228-L240" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    A similar problem occurs inside <a href="#Repeat">Repeat</a> or <a href="#Optional">Optional</a> parsers, where the parser will give up and backtrack out if it fails, even if it really should succeed. Again, adding cuts would result in a more precise error message:
</p>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val alpha = P( CharIn('a' to 'z') )
val stmt = P( &quot;val &quot; ~! alpha.rep(1).! ~ &quot;;&quot; ~ &quot; &quot;.rep )
val stmts = P( stmt.rep(1) ~ End )

val Result.Success(Seq(&quot;abcd&quot;), _) = stmts.parse(&quot;val abcd;&quot;)
val Result.Success(Seq(&quot;abcd&quot;, &quot;efg&quot;), _) = stmts.parse(&quot;val abcd; val efg;&quot;)

val failure = stmts.parse(&quot;val abcd; val &quot;).asInstanceOf[Result.Failure]
assert(
  failure.index == 14,
  failure.trace ==
    &quot;&quot;&quot;stmts:0 / stmt:10 / alpha:14 / CharIn(&quot;abcdefghijklmnopqrstuvwxyz&quot;):14 ...&quot;&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L242-L255" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    Another case where you may want to pay attention is when you are using delimiters with your <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> calls:
</p>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val digits = P( CharIn('0' to '9').rep(1) )
val tuple = P( &quot;(&quot; ~ digits.!.rep(sep=&quot;,&quot;) ~ &quot;)&quot; )

val Result.Success(Seq(&quot;1&quot;, &quot;23&quot;), _) = tuple.parse(&quot;(1,23)&quot;)

val failure = tuple.parse(&quot;(1,)&quot;).asInstanceOf[Result.Failure]
assert(
  failure.index == 2,
  failure.trace == &quot;&quot;&quot;tuple:0 / &quot;)&quot;:2 ...&quot;,)&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L257-L267" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    in many (but not all!) cases, if a delimiter is parsed, you want to commit to parsing one more iteration of the <a href="#Repeat">Repeat</a>. However, by default, it backtracks out of the <a href="#Repeat">Repeat</a> entirely and starts trying to parse the next item in sequence (in this case the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;)&quot;</code> giving the behavior shown above.
</p>
                <p>
                    With a cut, the error is improved:
</p>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val digits = P( CharIn('0' to '9').rep(1) )
val tuple = P( &quot;(&quot; ~ digits.!.rep(sep=&quot;,&quot; ~! Pass) ~ &quot;)&quot; )

val Result.Success(Seq(&quot;1&quot;, &quot;23&quot;), _) = tuple.parse(&quot;(1,23)&quot;)

val failure = tuple.parse(&quot;(1,)&quot;).asInstanceOf[Result.Failure]
assert(
  failure.index == 3,
  failure.trace == &quot;&quot;&quot;tuple:0 / digits:3 / CharIn(&quot;0123456789&quot;):3 ...&quot;)&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L269-L279" target="_blank"><i class="fa fa-link "></i></a></pre>

    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="ExampleParsers" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Example Parsers<a class=" scalatex-site-Styles-headerLink" href="#ExampleParsers" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <p>
            Above, we've already covered all the individual bits and pieces that make writing a parser possible. But how does that fit together? Let's take a look at some examples.
</p>
        <h1 id="Math" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Math" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Math</h1>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val number: P[Int] = P( CharIn('0'to'9').rep(1).!.map(_.toInt) )
val parens: P[Int] = P( &quot;(&quot; ~! addSub ~ &quot;)&quot; )
val factor: P[Int] = P( number | parens )

val divMul: P[Int] = P( factor ~ (CharIn(&quot;*/&quot;).! ~! factor).rep ).map(eval)
val addSub: P[Int] = P( divMul ~ (CharIn(&quot;+-&quot;).! ~! divMul).rep ).map(eval)
val expr: P[Int]   = P( addSub ~ End )</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/MathTests.scala#L18-L26" target="_blank"><i class="fa fa-link "></i></a></pre>


            <p>
                This is a small arithmetic expression parser, the same one shown at the top of this page. It parses only whole integers, parentheses, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">+-*/</code>, and no whitespace.</p>
            <p>
                Things to note:
</p>
            <ul>
                <li>
                    The various sub-parsers are all of type <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Int]</code>, indicating that they result in an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Int</code> if successful. Many of the type annotations could be removed due to type-inference, but they're shown here for clarity</li>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">divMul</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">addSub</code> are separated out, in order to properly account for precedence</li>
                <li>
                    We evaluate the expression as the parse progresses, meaning we never actually build an tree structure from the input string</li>
                <li>
                    In order to convert the parsed strings to integers, we <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">map</code> on the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">eval</code> function, which itself is defined earlier:
</li></ul>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def eval(tree: (Int, Seq[(String, Int)])) = {
  val (base, ops) = tree
  ops.foldLeft(base){ case (left, (op, right)) =&gt; op match{
    case &quot;+&quot; =&gt; left + right  case &quot;-&quot; =&gt; left - right
    case &quot;*&quot; =&gt; left * right case &quot;/&quot; =&gt; left / right
  }}
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/MathTests.scala#L10-L18" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                This is a small example, but it works. We check it using a helper to verify that every parse results in the expected integer:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def check(str: String, num: Int) = {
  val Result.Success(value, _) = expr.parse(str)
  assert(value == num)
}

check(&quot;1+1&quot;, 2)
check(&quot;1+1*2&quot;, 3)
check(&quot;(1+1*2)+(3*4*5)&quot;, 63)
check(&quot;15/3&quot;, 5)
check(&quot;63/3&quot;, 21)
check(&quot;(1+1*2)+(3*4*5)/20&quot;, 6)
check(&quot;((1+1*2)+(3*4*5))/3&quot;, 21)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/MathTests.scala#L28-L40" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Try it out yourself! Remember that it does not handle whitespace:
</p>
            <div id="mathdiv"></div>
            <script>demo.DemoMain().math(document.getElementById("mathdiv"))</script>

        <h1 id="Json" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Json" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Json</h1>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">// Here is the parser
val space         = P( CharsWhile(&quot; \n&quot;.contains(_)).? )
val digits        = P( CharsWhile('0' to '9' contains (_)))
val exponent      = P( CharIn(&quot;eE&quot;) ~ CharIn(&quot;+-&quot;).? ~ digits )
val fractional    = P( &quot;.&quot; ~ digits )
val integral      = P( &quot;0&quot; | CharIn('1' to '9') ~ digits.? )

val number = P( CharIn(&quot;+-&quot;).? ~ integral ~ fractional.? ~ exponent.? ).!.map(
  x =&gt; Js.Num(x.toDouble)
)

val `null`        = P( &quot;null&quot; ).map(_ =&gt; Js.Null)
val `false`       = P( &quot;false&quot; ).map(_ =&gt; Js.False)
val `true`        = P( &quot;true&quot; ).map(_ =&gt; Js.True)

val hexDigit      = P( CharIn('0'to'9', 'a'to'f', 'A'to'F') )
val unicodeEscape = P( &quot;u&quot; ~ hexDigit ~ hexDigit ~ hexDigit ~ hexDigit )
val escape        = P( &quot;\\&quot; ~ (CharIn(&quot;\&quot;/\\bfnrt&quot;) | unicodeEscape) )

val strChars = P( CharsWhile(!&quot;\&quot;\\&quot;.contains(_)) )
val string =
  P( space ~ &quot;\&quot;&quot; ~! (strChars | escape).rep.! ~ &quot;\&quot;&quot;).map(Js.Str)

val array =
  P( &quot;[&quot; ~! jsonExpr.rep(sep=&quot;,&quot; ~!, end=space ~ &quot;]&quot;)).map(Js.Arr(_:_*))

val pair = P( string.map(_.value) ~! &quot;:&quot; ~! jsonExpr )

val obj =
  P( &quot;{&quot; ~! pair.rep(sep=&quot;,&quot; ~!, end = space ~ &quot;}&quot; )).map(Js.Obj(_:_*))

val jsonExpr: P[Js.Val] = P(
  space ~ (obj | array | string | `true` | `false` | `null` | number) ~ space
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/JsonTests.scala#L37-L72" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                This is a somewhat larger example than the math parser shown above. In it, we parse a JSON expression from a string, including all the proper handling for whitespace and error-handling built in.
</p>
            <p>
                Things to note:
</p>
            <ul>
                <li>
                    We use cuts (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~!</code>) liberally in order to improve the quality of errors. Anywhere there's an <a href="#Either">Either</a> or <a href="#Repeat">Repeat</a>, the children have cuts once the parse has progressed far enough backtracking isn't an option.</li>
                <li>
                    We use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharIn</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharsWhile</code> quite a lot, in order to speed up the common case of consuming lots of boring characters.</li>
                <li>
                    In <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">strChars</code>, we break out of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharsWhile</code> closing quote (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">'&quot;'</code>) or whenever we see the start of an escape sequence (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">'\'</code>). Although <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharsWhile</code> can't process these multi-char sequences, we let the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">escape</code> parser deal with these before trying to fall back to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">strChars</code> after. This lets us speed up the &quot;common&quot; case of consuming large numbers of non-escape characters, while still properly handling escapes.</li>
                <li>
                    We use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.map</code> to convert the various things we parse into instances of our own <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Js.Val</code> JSON AST:

</li></ul>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">object Js {
  sealed trait Val extends Any {
    def value: Any
    def apply(i: Int): Val = this.asInstanceOf[Arr].value(i)
    def apply(s: java.lang.String): Val =
      this.asInstanceOf[Obj].value.find(_._1 == s).get._2
  }
  case class Str(value: java.lang.String) extends AnyVal with Val
  case class Obj(value: (java.lang.String, Val)*) extends AnyVal with Val
  case class Arr(value: Val*) extends AnyVal with Val
  case class Num(value: Double) extends AnyVal with Val
  case object False extends Val{
    def value = false
  }
  case object True extends Val{
    def value = true
  }
  case object Null extends Val{
    def value = null
  }
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/JsonTests.scala#L15-L37" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                We can verify that this parser builds the JSON tree that we expect:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val Result.Success(value, _) = jsonExpr.parse(
  &quot;&quot;&quot;{&quot;omg&quot;: &quot;123&quot;, &quot;wtf&quot;: 12.4123}&quot;&quot;&quot;
)
assert(value == Js.Obj(&quot;omg&quot; -&gt; Js.Str(&quot;123&quot;), &quot;wtf&quot; -&gt; Js.Num(12.4123)))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/JsonTests.scala#L88-L92" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                And that it provides good error messages in the case of mal-formed JSON, even for moderately-sized fragemnts
</p>
            
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">{
    &quot;firstName&quot;: &quot;John&quot;,
    &quot;lastName&quot;: &quot;Smith&quot;,
    &quot;age&quot;: 25,
    &quot;address&quot;: {
        &quot;streetAddress&quot;: &quot;21 2nd Street&quot;,
        &quot;city&quot;: &quot;New York&quot;,
        &quot;state&quot;: &quot;NY&quot;,
        &quot;postalCode&quot;: 10021
    },
    &quot;phoneNumbers&quot;:
        {
            &quot;type&quot;: &quot;home&quot;,
            &quot;number&quot;: &quot;212 555-1234&quot;
        },
        {
            &quot;type&quot;: &quot;fax&quot;,
            &quot;number&quot;: &quot;646 555-4567&quot;
        }
    ]
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/JsonTests.scala#L269-L290" target="_blank"><i class="fa fa-link "></i></a></pre>

            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">jsonExpr:0 / obj:9 / pair:438 / string:438 / &quot;\&quot;&quot;:455 ...&quot;{\n        &quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/JsonTests.scala#L292-L293" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Here, we're missing a square bracket after the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;phoneNumbers&quot;</code> key, and so the parser expects to find a single JSON expression. It finds a JSON object, and then fails reporting that it expected to find the next key (a string), but instead found <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;{\n&quot;</code> at that index.
</p>
            <p>
                Try it out!
</p>
            <div id="jsondiv"></div>
            <script>demo.DemoMain().json(document.getElementById("jsondiv"))</script>

    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="APIHighlights" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">API Highlights<a class=" scalatex-site-Styles-headerLink" href="#APIHighlights" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>

        <h1 id="Parser[T]" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Parser[T]" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Parser[T]</h1>
            <p>
                Fastparse revolves around <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[T]</code>s: a parser that can attempt to parser a value <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">T</code> from an input string. These are defined as:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">trait Parser[+T] extends ParserApi[T]{
  /**
   * Parses the given `input` starting from the given `index`
   *
   * @param input The string we want to parse
   *
   * @param index The index in the string to start from. By default parsing
   *              starts from the beginning of a string, but you can start
   *              from halfway through the string if you want.
   *
   * @param trace Whether or not you want a full trace of any error messages
   *              that appear. Without it, you only get the single deepest
   *              parser in the call-stack when it failed, and its index. With
   *              `trace`, you get every parser all the way to the top, though
   *              this comes with a ~20-40% slowdown.
   *
   * @param instrument Allows you to pass in a callback that will get called
   *                   by every named rule, its index, as it itself given a
   *                   callback that can be used to recurse into the parse and
   *                   return the result. Very useful for extracting auxiliary
   *                   information from the parse, e.g. counting rule
   *                   invocations to locate bottlenecks or unwanted
   *                   backtracking in the parser.
   */
  def parse(input: String,
            index: Int = 0,
            trace: Boolean = true,
            instrument: (Parser[_], Int, () =&gt; Result[_]) =&gt; Unit = null)
            : Result[T] = {
    parseRec(ParseCtx(input, 0, trace, instrument), index)
  }

  /**
   * Parses the given `input` starting from the given `index` and `logDepth`
   */
  def parseRec(cfg: ParseCtx, index: Int): Result[T]

  /**
   * Whether or not this parser should show up when [[Failure.trace]] is called
   */
  def shortTraced: Boolean = false
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/main/scala/fastparse/core/Parsing.scala#L158-L201" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                The main external API is <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.parse</code>. As you can see, apart from the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">input</code> parameter, there are a few parameters that you can use to configure the parse. Apart from that, each <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[T]</code> needs to implement <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">parseRec</code> which is a less-convenient but more-performant version that FastParse uses internally when performing a parse.</p>
            <p>
                Although the core of <a href="#Parser[T]">Parser[T]</a> is simple, a lot of additional functionality is included in the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ParserApi[T]</code> trait in order to make constructing parsers convenient and concise.
</p>
        <h1 id="ParserApi[T]" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ParserApi[T]" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>ParserApi[T]</h1>
            <p>
                Apart from the core <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser</code>, FastParse includes a large set of operations that you can perform on a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser</code> to make composing them more pleasant. These all live in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ParserApi</code>:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe"></code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/main/scala/fastparse/core/Parsing.scala" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                There are essentially all short-hand constructors for the parsers in the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">object Parser</code> companion. This is the list of operators that you have available when writing your own parsers using FastParse.
</p>
        <h1 id="Results" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Results" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Results</h1>
            <p>
                The two kinds of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result</code>s let you pattern match to extract the most commonly-used values: for a success, you can extract the resultant value, while a failure provides the last parser which failed. Both also provide the index into the string where the parse succeeded or failed.
</p>
            <p>
                Apart from that, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result</code>s also provide other useful information about a parse:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">trait Success[T] extends Result[T]{
  /**
   * The result of this parse
   */
  def value: T
  /**
   * The index where the parse completed; may be less than
   * the length of input
   */
  def index: Int
  /**
   * Whether or not this parse encountered a Cut
   */
  def cut: Boolean
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/main/scala/fastparse/core/Parsing.scala#L16-L31" target="_blank"><i class="fa fa-link "></i></a></pre>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">trait Failure extends Result[Nothing]{
  /**
   * The input string for the failed parse. Useful so the [[Failure]]
   * object can pretty-print snippet
   */
  def input: String

  /**
   * The entire stack trace where the parse failed, containing every
   * parser in the stack and the index where the parser was used, excluding
   * the final parser and index where the parse failed
   */
  def fullStack: List[Frame]
  /**
   * A slimmed down version of [[fullStack]], this only includes named
   * [[parsers.Combinators.Rule]] objects as well as the final Parser (whether named or not)
   * and index where the parse failed for easier reading.
   */
  def stack: List[Frame]

  /**
   * The index in the parse where this parse failed
   */
  def index: Int

  /**
   * The deepest parser in the parse which failed
   */
  def parser: Parser[_]

  /**
   * A one-line snippet that tells you what the state of the
   * parser was when it failed
   */
  def trace: String
  /**
   * A longer version of [[trace]], which shows more context
   * for every stack frame
   */
  def verboseTrace: String

  /**
   * Whether or not this parse encountered a Cut
   */
  def cut: Boolean
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/main/scala/fastparse/core/Parsing.scala#L41-L87" target="_blank"><i class="fa fa-link "></i></a></pre>

    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Performance" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Performance<a class=" scalatex-site-Styles-headerLink" href="#Performance" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <p>
            FastParse will never be able to compete with hand-written recursive descent parsers for speed. However, it's no slouch either; here's a comparison of FastParse with alternatives, using Parboiled2's JSON parsing benchmark, which parses a ~21,500 line JSON file:
</p>
        <table style="width: 100%;">
            <thead>
                <th>Benchmark</th><th>Score</th><th>Error</th></thead>
            <tbody>
                <tr>
                    <td>fastparse</td><td>80.536</td><td>± 0.942</td></tr>
                <tr>
                    <td>fastparse-no-trace</td><td>89.873</td><td>± 0.875</td></tr>
                <tr>
                    <td>argonaut</td><td>164.092</td><td>± 2.869</td></tr>
                <tr>
                    <td>json4s-jackson</td><td>285.637</td><td>± 3.954</td></tr>
                <tr>
                    <td>json4s-native</td><td>142.964</td><td>± 2.076</td></tr>
                <tr>
                    <td>parboiled2</td><td>87.586</td><td>± 1.176</td></tr>
                <tr>
                    <td>scala-parser-combinators</td><td>0.976</td><td>± 0.018</td></tr>
                <tr>
                    <td>spray-json</td><td>189.784</td><td>± 2.825</td>

</tr></tbody></table>
        <p>
            These numbers are the number of iterations/second of parsing a sample <code>test.json</code> file, averaged over 200 runs. As you can see, the FastParse based parser comes within a factor of 4 of the fastest hand written parser (Jackson), is just as fast as the Parboiled2 based parser (slightly faster/slower depending if full tracing is enabled), and is almost 100x faster than the scala-parser-combinators library.
</p>
        <p>
            In exchange for the perf hit compared to hand-rolled solutions, you get the <a href="#Json">short, super-simple parser definition</a>, and excellent error free error reporting. While for super-high-performance use cases you may still want a hand-rolled parser, for many ad-hoc situations a FastParse parser would do just fine. Remember, even at &quot;only&quot; 89 iterations per second that is still parsing 1,900,000 lines of JSON every second!
</p>
        <p>
            A similar speed ratio can be seen in parsing a <a href="https://github.com/scala-js/scala-js/blob/master/compiler/src/main/scala/org/scalajs/core/compiler/GenJSCode.scala">sample Scala file</a> using FastParse, Parboiled2 and Scalac's inbuilt hand-written Scala-language parser:
</p>
        <table style="width: 100%;">
            <thead>
                <th>Benchmark</th><th>Score</th><th>Error</th></thead>
            <tbody>
                <tr>
                    <td>fastparse</td><td>320.7</td><td>15.4</td></tr>
                <tr>
                    <td>fastparse-no-trace</td><td>434.7</td><td>23.4</td></tr>
                <tr>
                    <td>parboiled2</td><td>1354</td><td>7.97</td></tr>
                <tr>
                    <td>scalac</td><td>4888</td><td>113</td>
</tr></tbody></table>
        <p>
            These numbers are the number of iterations over 30 seconds, average of 4 runs, with 2 runs of warmup (discarded). FastParse performs worse here, at 11.5x slower than Scalac's in-built parser, and 3x slower than the equivalent Parboiled2-based parser. Depending on what you're doing, that may or may not be a problem: ScalaParse still makes progress at 57,027 lines of Scala per second, which despite being slower than the others is still blazing fast.
</p>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Internals" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Internals<a class=" scalatex-site-Styles-headerLink" href="#Internals" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <p>
            FastParse's internals are straightforward, at less than 1000 lines of code. Nonetheless, its design is unlike any other combinator library I've seen: externally immutable, pure-functional parser-combinators with mutable, highly-optimized internals.
</p>
        <h1 id="FastInterpreter" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#FastInterpreter" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Fast Interpreter</h1>
            <p>
                FastParse is designed as a fast, immutable interpreter. That means</p>
            <ul>
                <li>
                    It does not do significant transformations of the grammar. The structure of the parser you define is the structure that will run. No transformation at compile time, no transformations at run-time.</li>
                <li>
                    It provides fast primitives like <a href="#CharsWhile">CharsWhile</a>, that you can drop in many places to speed up otherwise slow bulk operations (e.g. parsing whitespace, identifiers).</li>
                <li>
                    Error reported is straightforward: the last index that it does not backtrack out of is the index that is reported, and the parser at that point is the parser that is reported.
</li></ul>
            <p>
                In theory, it could be possible to perform either compile-time or initialization-time (before actually parsing) optimizations on the parser to improve performance. So far, I have not managed to find a scheme that has a significant improvement at an acceptable cost in terms of complexity. Apart from trivial de-sugarings (e.g. merging together <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">(p1 | p2) | p3</code> into a single <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Either</code> node) what you write is what gets run
</p>
        <h1 id="ExternalImmutabiliy" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ExternalImmutabiliy" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>External Immutabiliy</h1>

            <p>
                FastParse presents a pure-functional, immutable external API to the user. That means that you can call <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[T]#parse</code> and not worry about having to set up neccessary state or instantiating objects. You take a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[T]</code>, call <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.parse</code>, and get a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Success[T]</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Failure</code>
</p>
            <p>
                However, immutability poses a challenge: immutability usually involves lots of &quot;copy &amp; update&quot; operations rather than &quot;mutation&quot; operations, and on the JVM that means excessive garbage generation and collection. This is harmful for performance.
</p>
            <p>
                Thus FastParse performs some tricks internally to save allocations: the immutable <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Success</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Failure</code> result types are actually interfaces hiding <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Success.Mutable</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Failure.Mutable</code> implementations, which have entirely mutable fields.
</p>
            <p>
                This means that the same <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Success.Mutable</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Failure.Mutable</code> objects are shared throughout an entire parsing run, mutated as the parse progresses, while the external user only sees an immutable facade. This also means that a run of the large-and-complex <a href="#ScalaParse">ScalaParse</a> on a hundreds-of-kb source file results in exactly <i>three</i> allocations in all: one <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Success.Mutable</code>, one <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Failure.Mutable</code>, and one <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Ctx</code> object holding them together.
</p>
        <h1 id="InternalOptimizations" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#InternalOptimizations" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Internal Optimizations</h1>
            <p>
                FastParse does some things that take advantage of the type-directed nature of the result-aggregation: while <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[T].rep</code> returns a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Seq[T]]</code> for an arbitrary <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">T</code>, there is a short circuit such that <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Unit].rep</code> simple returns <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Unit]</code>. This lets the common case of &quot;parsing things, not caring about the result&quot; avoid the allocation, while still allowing you to stick some other type in there (e.g. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Any</code>) if you really do care about the bucket-of-<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Unit</code>s.
</p>
            <p>
                FastParse also takes advantage of the fact that <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser</code>s are immutable. That makes it feasible to make instantiation mildly-expensive, since each one only gets instantiated once rather than per-parse. As an example, <a href="#CharIn">CharIn</a>, <a href="#CharPred">CharPred</a> and <a href="#CharsWhile">CharsWhile</a> all have their predicate converted to an identical bit-set to make character lookups extremely fast. Similarly, <a href="#StringIn">StringIn</a> gets converted into a Trie in order to allow one-pass matching of dozens of strings at the same time.</p>
            <p>
                These operations are not cheap: the bitsets easily take a few KB of memory each, and involve 65k iterations to fill them in. However, since <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser</code>s are immutable, this one-time-cost goes from &quot;ridiculous&quot; to &quot;acceptable&quot;. All these internal optimizations are completely opaque to the user, who (apart from performance) never need to think about them.

</p>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Comparisons" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Comparisons<a class=" scalatex-site-Styles-headerLink" href="#Comparisons" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <p>
            FastParse differs from all other parser-combinator libraries in the Scala universe, in quite substantial ways:
</p>
        <ul>
            <li>
                Compared to <a href="https://github.com/sirthias/parboiled2">Parboiled2</a>, FastParse does not use macros to compile-time-generate fast parser code. Rather, it acts as an efficient interpreter, sacrificing some speed (1-4x slower) for huge amounts of usability. Parboiled2 in particular has <a href="https://groups.google.com/forum/#!msg/scala-internals/4N-uK5YOtKI/9vAdsH1VhqAJ">usability problems and bugs</a> that make it excruciating difficult to use, and also does not support higher-order rules. FastParse suffers from none of these problems.</li>
            <li>
                <a href="https://github.com/sirthias/parboiled/wiki">Parboiled1</a> is a Java library, and does not/cannot work on Scala.js</li>
            <li>
                <a href="https://github.com/scala/scala-parser-combinators">scala-parser-combinators</a> is similar, but poorly executed. It is ~100x slower than FastParse, has an awkward inheritance-based API, and is full of bugs despite being half a decade old. FastParse is faster, has self-contained pure-functional parsers, and fixes bugs e.g. by having the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log</code> operator actually work.
</li></ul></div>
<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="ScalaParse" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">ScalaParse<a class=" scalatex-site-Styles-headerLink" href="#ScalaParse" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div><div class=" scalatex-site-Styles-content">

    <div id="scaladiv"></div>
    <script>demo.DemoMain().scalaparser(document.getElementById("scaladiv"))</script>

    <p>
        ScalaParse is a parser for the entire Scala programming language, written using FastParse. This is notable for a few reasons:
</p>
    <ul>
        <li>
            ScalaParse is about 700 lines of code, making it about 1/10th the size of the default parser in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">tools.nsc.Global</code></li>
        <li>
            ScalaParse runs about <a href="#Performance">1/8th the speed</a> of of the default parser in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">tools.nsc.Global</code></li>
        <li>
            ScalaParse has excellent error reporting due to proper use of <a href="#Cuts">Cuts</a>, without any code explicitly dedicated to error reporting</li></ul>
    <p>
        ScalaParse does not currently generate an AST. As you can see, the parse result above is listed as <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">undefined</code>. However, that does not make it useless! Even without generating an AST, ScalaParse can be used to:
</p>
    <ul>
        <li>
            Check for errors! ScalaParse provides excellent error reporting on parses, equal or better than that provided by the tools.nsc.Global parser, entirely for free.</li>
        <li>
            Prototype extensions to the Scala grammar! Unlike the default tools.nsc.Global parser, ScalaParse makes it trivial to add new rules at various sections of the grammar.</li>
        <li>
            Manipulate Scala code sections! It's trivial to wrap various rules in ScalaParse in an <a href="#Capture">Capture</a> and use it to pull out the relevant bits of a Scala file for you to use.</li>
        <li>
            Learn how
</li></ul>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="UsingScalaParse" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Using ScalaParse<a class=" scalatex-site-Styles-headerLink" href="#UsingScalaParse" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <p></p>
        To begin using ScalaParse, add

        <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %% &quot;scalaparse&quot; % &quot;0.1.7&quot;
</code></pre>
        <p>
            To your SBT configuration. To use with Scala.js, you'll need
</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %%% &quot;scalaparse&quot; % &quot;0.1.7&quot;
</code></pre></div>
<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="ChangeLog" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Change Log<a class=" scalatex-site-Styles-headerLink" href="#ChangeLog" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div><div class=" scalatex-site-Styles-content">
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="0.1.7" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">0.1.7<a class=" scalatex-site-Styles-headerLink" href="#0.1.7" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <ul>
            <li>
                More fixes for ScalaParse, added more projects to test suite</li>
            <li>
                Auto-generate <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Sequencer</code> instances up to 22</li>
            <li>
                Removed unnecessary runtime utest dependency</li></ul>
    <div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="0.1.6" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">0.1.6<a class=" scalatex-site-Styles-headerLink" href="#0.1.6" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
        <ul>
            <li>
                Introduced five new projects into the test suite: ScalaIDE, GitBucket, Scalding, Scaloid, Marathon</li>
            <li>
                Fixed bug in ScalaParse around using function <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">=&gt;</code> types as type ascriptions</li>
            <li>
                Added ability to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">instrument</code> parsers, in order to gather out-of-band information about them e.g. for debugging or profiling</li>
            <li>
                Added <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">IgnoreCase</code> combinator, for case-insensitive string matching</li>
            <li>
                Cross-published for Scala 2.10
</li></ul></div>
</div><script>
    scalatex.scrollspy.Controller().main(
      [{"value":"FastParse 0.1.7","children":[{"value":"Getting Started","children":[]},{"value":"Writing Parsers","children":[{"value":"Basic","children":[{"value":"Sequence","children":[]},{"value":"Repeat","children":[]},{"value":"Optional","children":[]},{"value":"Either","children":[]},{"value":"End, Start","children":[]},{"value":"Pass, Fail","children":[]},{"value":"Index","children":[]},{"value":"Capturing","children":[]},{"value":"AnyChar","children":[]},{"value":"Positive Lookahead","children":[]},{"value":"Negative Lookahead","children":[]},{"value":"Map","children":[]},{"value":"FlatMap","children":[]},{"value":"Filter","children":[]}]},{"value":"Intrinsics","children":[{"value":"CharPred","children":[]},{"value":"CharIn","children":[]},{"value":"CharsWhile","children":[]},{"value":"StringIn","children":[]}]},{"value":"Cuts","children":[{"value":"No Cuts","children":[]},{"value":"Cuts","children":[]},{"value":"Rep Cuts","children":[]}]}]},{"value":"Example Parsers","children":[{"value":"Math","children":[]},{"value":"Json","children":[]}]},{"value":"API Highlights","children":[{"value":"Parser[T]","children":[]},{"value":"ParserApi[T]","children":[]},{"value":"Results","children":[]}]},{"value":"Performance","children":[]},{"value":"Internals","children":[{"value":"Fast Interpreter","children":[]},{"value":"External Immutabiliy","children":[]},{"value":"Internal Optimizations","children":[]}]},{"value":"Comparisons","children":[]}]},{"value":"ScalaParse","children":[{"value":"Using ScalaParse","children":[]}]},{"value":"Change Log","children":[{"value":"0.1.7","children":[]},{"value":"0.1.6","children":[]}]}]
  )</script><script>
    ['DOMContentLoaded', 'load'].forEach(function(ev){
      addEventListener(ev, function(){
        Array.prototype.forEach.call(
          document.getElementsByClassName('scalatex-site-Styles-highlightMe'),
          hljs.highlightBlock
        );
      })
    })
  </script></body></html>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    